(function() { var c, sizeType = 'normal'; width = 0; height = 0; halfWidth = 0; halfHeight = 0; PERCENT = '%'; NUM = 'num'; var s = { x: PERCENT, y: PERCENT, width: PERCENT, height: PERCENT, radius: PERCENT, scale: PERCENT }, s1 = 0xFFFFFF, s2 = 0xCCCCCC, s3 = 0xFF00FF, resolution = 0.01; Object.getOwnPropertyNames(Math).forEach(function(name) { window[name] = Math[name]; }); resetSeeds = function() { s1 = 0xFFFFFF; s2 = 0xCCCCCC; s3 = 0xFF00FF; }; rand = function() { var r; s1 = ((s1 & 4294967294) << 12) ^ (((s1 << 13) ^ s1) >> 19); s2 = ((s2 & 4294967288) << 4) ^ (((s2 << 2) ^ s2) >> 25); s3 = ((s3 & 4294967280) << 17) ^ (((s3 << 3) ^ s3) >> 11); r = (s1 ^ s2 ^ s3) * 2.3283064365e-10; return r < 0 ? ++r : r; }; units = function(prop, value) { s[prop] = value; return units; }; size = function() { if (sizeType === 'width') { return width; } else if (sizeType === 'height') { return height; } return min(width, height); }; useWidth = function() { sizeType = 'width'; }; useHeight = function() { sizeType = 'height'; }; // case for useMax? useMin = function() { sizeType = 'normal'; }; var hexWithAlpha = function(color, alpha) { var r, g, b, nColor = ''; if (typeof color === 'string' && alpha != null) { color = color.substr(1); if (color.length === 3){ for (var i = 0; i < 3; i++){ nColor += color.charAt(i) + color.charAt(i); } color = nColor; } color = parseInt(color, 16); r = color >> 16 & 0xff; g = color >> 8 & 0xff; b = color & 0xff; return [ 'rgba(', r, ',', g, ',', b, ',', alpha, ')' ].join(''); } return color; } fill = function(color, alpha) { color = hexWithAlpha(color, alpha); c.fillStyle = color; }; background = function(color, alpha) { fill(color, alpha); rect(0, 0, 1, 1); }; shadow = function(p) { p.color && (c.shadowColor = hexWithAlpha(p.color, p.alpha)); (p.blur != null) && (c.shadowBlur = p.blur); (p.x != null) && (c.shadowOffsetX = p.x); (p.y != null) && (c.shadowOffsetY = p.y); }; stroke = function(color, alpha) { color = hexWithAlpha(color, alpha); c.strokeStyle = color; }; strokeWidth = function(width) { c.lineWidth = width; }; noFill = function() { c.fillStyle = 'rgba(0,0,0,0)'; }; noStroke = function() { c.strokeStyle = 'rgba(0,0,0,0)'; }; rect = function(x, y, w, h) { x = (s.x === NUM) ? x : width * x; y = (s.y === NUM) ? y : height * y; w = (s.width === NUM) ? width : width * w; h = (s.height === NUM) ? height : height * h; c.fillRect(x, y, w, h); c.strokeRect(x, y, w, h); }; circle = function(x, y, radius) { x = (s.x === NUM) ? x : width * x; y = (s.y === NUM) ? y : height * y; radius = (s.radius === NUM) ? radius : size() * radius; c.beginPath(); c.arc(x, y, radius, 0, PI * 2, false); c.fill(); c.stroke(); }; para = parametric = function(xOff, yOff, p) { if (arguments.length === 1) { var x = (s.x === NUM) ? width / 2 : 0.5, y = (s.y === NUM) ? height / 2 : 0.5; parametric(x, y, xOff); return; } var range = p.range || [0, 1], step = p.step || resolution, scale = size() * (p.scale || 1); xOff = (s.x === NUM) ? xOff : width * xOff; yOff = (s.y === NUM) ? yOff : height * yOff; if (range[0] < range[1]) { c.beginPath(); for (var t = 0; t <= range[1]; t += step) { var loc = p.f(t); c.lineTo(xOff + loc.x * scale, yOff + loc.y * scale); } p.close && c.closePath(); c.fill(); c.stroke(); } }; polar = function(xOff, yOff, p) { if (arguments.length === 1) { var x = (s.x === NUM) ? width / 2 : 0.5, y = (s.y === NUM) ? height / 2 : 0.5; polar(x, y, xOff); return; } var range = p.range || [0, 2 * PI], step = p.step || resolution, radMult = (p.radius === NUM) ? 1 : size(), x, y, r; xOff = (s.x === NUM) ? xOff : width * xOff; yOff = (s.y === NUM) ? yOff : height * yOff; if (range[0] < range[1]) { c.beginPath(); for (var t = 0; t <= range[1]; t += step) { r = p.radius(t) * radMult; x = xOff + r * cos(t); y = yOff + r * sin(t); c.lineTo(x, y); } (p.close || p.close == undefined) && c.closePath(); c.fill(); c.stroke(); } }; repeat = function(num, func) { for (var i = 0; i < num; i++){ func(i); } }; range = function(start, end, step, func) { for (var i = start; i <= end; i += step) { func(i); } }; grid = function(rows, cols, func) { for (var y = 0; y < rows; y++) { for (var x = 0; x < cols; x++) { } } }; rez = function(val) { resolution = val; }; window.Z = window.z = function(main) { document.body.setAttribute('style', 'margin: 0; padding; 0; overflow: hidden;'); canvas = document.body.appendChild(document.createElement('canvas')); context = c = canvas.getContext('2d'); draw = main; canvas.setAttribute('style', '-webkit-transform-origin: 0 0; -webkit-transform: scale(0.5);' + '-moz-transform-origin: 0 0; -moz-transform: scale(0.5);' + '-ms-transform-origin: 0 0; -ms-transform: scale(0.5);' + 'transform-origin: 0 0; transform: scale(0.5);' ); var redrawEvent = new Event('redraw'); var ua = window.navigator.userAgent.toLowerCase(); var isIOS = function() { return /(ipad|iphone)/i.test(ua); }; var isPad = function() { return /(ipad)/i.test(ua); }; var resize = function(e) { width = window.innerWidth * 2; height = window.innerHeight * 2; if (isIOS()) { width = window.screen.availWidth * 2; height = window.screen.availHeight * 2; var isPortrait = isPad() ? (window.orientation === 0) : window.innerHeight < window.innerWidth; if (isPortrait) { var t = width; width = height + 40; height = t - (isPad() ? 120 : 0); } else { height -= 120 - (isPad() ? 30 : 0); } } halfWidth = width / 2; halfHeight = height / 2; canvas.width = width; canvas.height = height; strokeWidth(4); resetSeeds(); draw(); }; window.addEventListener('resize', resize); window.addEventListener('orientationchange', resize); resize(); }; })();